#include "Windows.h"
#include "winternl.h"

#define NEW_STREAM L":Maldev"

void AsciiToWideString(IN PCHAR strIn, OUT PWCHAR strOut) {
	mbstate_t state;
	SIZE_T strInLen = strlen(strIn);
	SIZE_T retVal = 0;
	memset(&state, 0, sizeof(state));
	mbsrtowcs_s(&retVal, strOut, 1 + (strInLen * sizeof(WCHAR)), &strIn, strInLen, &state);
}

BOOL isCurrentProcessDebugged() {
	// Check PEB
#ifdef _M_X64
	PPEB pPeb = __readgsqword(12 * sizeof(PVOID));
#else
	PPEB pPeb = __readfsdword(12 * sizeof(PVOID));
#endif
	if (pPeb == NULL || pPeb->BeingDebugged) {
		return TRUE;
	}

	// Check hardware debug registers; dr0, dr1, dr2, dr3
	CONTEXT cThread = {.ContextFlags = CONTEXT_DEBUG_REGISTERS };
	if (!GetThreadContext(GetCurrentThread(), &cThread)) {
		return TRUE;
	}
	if (cThread.Dr0 || cThread.Dr1 || cThread.Dr2 || cThread.Dr3) {
		return TRUE;
	}

	// Check process information
	HMODULE hNtdll = GetModuleHandleA("ntdll.dll");
	if (hNtdll == NULL) {
		return TRUE;
	}
	PVOID pNtQueryInformationProcess = GetProcAddress(hNtdll, "NtQueryInformationProcess");
	if (pNtQueryInformationProcess == NULL) {
		return TRUE;
	}
	NTSTATUS(*NtQueryInformationProcess)(HANDLE ProcessHandle, PROCESSINFOCLASS ProcessInformationClass, PVOID ProcessInformation, ULONG ProcessInformationLength, PULONG ReturnLength) = (NTSTATUS(*)())pNtQueryInformationProcess;
	DWORD debugPort = 0;
	DWORD debugPortReturnLen = 0;
	if (!NtQueryInformationProcess(GetCurrentProcess(), ProcessDebugPort, &debugPort, sizeof(DWORD), &debugPortReturnLen)) {
		return TRUE;
	}
	if (debugPort != 0) {
		return TRUE;
	}
	
	// Check for debugger SEH handling
	__try {
		DebugBreak();
	}
	__except (GetExceptionCode() == EXCEPTION_BREAKPOINT ? EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH) {
		return FALSE;
	}

	// If none of the checks confirm that process is not being debugged, return NOT DEBUGGED status
	return TRUE;
}

BOOL DeleteSelf(PWCHAR newStreamNameForDeletion) {
	// Get current file
	WCHAR currentModuleName[MAX_PATH * sizeof(WCHAR)];
	GetModuleFileNameW(NULL, currentModuleName, MAX_PATH * sizeof(WCHAR));

	// Rename :$DATA ADS to a new one
	HANDLE hFile = CreateFileW(currentModuleName, DELETE | SYNCHRONIZE, FILE_SHARE_READ, NULL, OPEN_EXISTING, NULL, NULL);
	if (hFile == INVALID_HANDLE_VALUE) {
		return FALSE;
	}
	DWORD newStreamNameSize = wcslen(newStreamNameForDeletion) * sizeof(WCHAR);
	DWORD fileNameInfoSize = sizeof(FILE_RENAME_INFO);

	PFILE_RENAME_INFO pFileRenameInfo = VirtualAlloc(NULL, fileNameInfoSize, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
	if (pFileRenameInfo == NULL) {
		return FALSE;
	}
	RtlZeroMemory(pFileRenameInfo, fileNameInfoSize);
	pFileRenameInfo->FileNameLength = newStreamNameSize;
	RtlCopyMemory(pFileRenameInfo->FileName, newStreamNameForDeletion, newStreamNameSize);

	if (!SetFileInformationByHandle(hFile, FileRenameInfo, pFileRenameInfo, fileNameInfoSize)) {
		return FALSE;
	}
	CloseHandle(hFile);

	// Delete new ADS
	FILE_DISPOSITION_INFO fileDispositionInfo = { .DeleteFileW = TRUE };
	hFile = CreateFileW(currentModuleName, DELETE, FILE_SHARE_DELETE, NULL, OPEN_EXISTING, NULL, NULL);
	if (hFile == INVALID_HANDLE_VALUE) {
		return FALSE;
	}
	if (!SetFileInformationByHandle(hFile, FileDispositionInfo, &fileDispositionInfo, sizeof(fileDispositionInfo))) {
		return FALSE;
	}
	CloseHandle(hFile);

	// Cleanup
	VirtualFree(pFileRenameInfo, 0, MEM_RELEASE);

	return TRUE;
}

void main() {
	BOOL isDebugged = isCurrentProcessDebugged();

	if (isDebugged) {
		DeleteSelf(L":SOMETHING");
	}
}